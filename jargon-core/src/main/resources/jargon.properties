encoding=UTF-8
#-------------------
# parallel transfer thread pooling behavior - work-in-progress
#-------------------

# set to true to use a transfer thread pool, or false to use the old algorithm
#  NOTE: the use of this pool is still experimental, use with caution!!!!!
transfer.use.pool=false
# maximum pool size for transfer threads, expressed as the number of simultaneous parallel transfers.  This will be multiplied by the 
# transfer.max.parallel.threads value to arrive at a pool size
transfer.executor.pool.max.simultaneous.transfers=2
# timeout for threads in the transfer pool in millis
transfer.executor.pool.timeout=60000
# interim patch code to correct parallel transfer cap behavior
# length in mb
transfer.send.max.threads.threshold=33554432

#------------------
# i/o pipeline tuning - work in progress
#------------------

# buffer sized used in parallel get/put threads FIXME needs impl to replace constant, currently no effect
transfer.parallel.buffer.size=2048
# time out (in seconds) for iRODS connections to the main control channel (typicall 1247)
socket.timeout=0
# time out (in seconds) for socket connections for parallel transfer threads
parallel.socket.timeout=120
# internal buffer size used for the input stream between Jargon and iRODS  (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.internal.input.stream.buffer.size=0
# internal buffer size used for the output stream between Jargon and iRODS  (0 = use defaults, -1 = do not wrap with buffered output stream)
jargon.io.internal.output.stream.buffer.size=-1
#  Get the size of the internal buffer cache used to accumulate data being sent to iRODS.   (0 =  do not utilize the cache buffer)
jargon.io.internal.cache.buffer.size=65535
# buffer size used for the input stream being sent to iRODS. (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.send.input.stream.buffer.size=0
#  size of the buffer used in read/write operations (read into, and write from this buffer in the read/write loop).
jargon.io.input.to.output.copy.byte.buffer.size=65536
# size of buffer used in output stream to a local file  (0 = use defaults, -1 = do not wrap with buffered output stream)
jargon.io.local.output.stream.buffer.size=16384
# size of buffer used in input stream from a local file  (0 = use defaults, -1 = do not wrap with buffered input stream)
jargon.io.local.input.stream.buffer.size=16384
# size of buffer used in put operations (file segment size per call to DataObjInp)
jargon.put.buffer.size=4194304
# size of buffer used in get operations (file segment size per call to DataObjInp)
jargon.get.buffer.size=4194304
# enables reconnect option sent in startup pack and used in connection handling (as in teh -T icommand option (work in progress)
jargon.reconnect=true
# if jargon.reconnect is true, this is the time in milliseconds before restarting, default is 10 minutes
#jargon.reconnect.time.in.millis=6000
jargon.reconnect.time.in.millis=600000

# turns on detailed instrumentation code which will be reported in the DEBUG log. Production of this data will be implemented over time
jargon.instrument=false

#------------------
#max query results tuning 
#------------------
max.files.and.dirs.query.max=5000

#-----------------
# Misc transfer behaviors
#-----------------

#allow resource redirects (redirect transfers to resource server containing file)
transfer.allow.redirects=false
#compute a checksum for every file put to iRODS (does not do a verification/comparison)
transfer.compute.checksum=false
#compute a checksum for every file put/get to iRODS and verify
transfer.computeandvalidate.checksum=false
#send within-file status call-backs on transfers (slight performance penalty, but allows monitoring of file progress if 'true'
transfer.intra.file.callbacks=false
#do not allow parallel trasfers at all
transfer.use.parallel=true
#use NIO variant for parallel transfers (use java nio transferTo between the local file system and iRODS) - EXPERIMENTAL
transfer.use.nio.for.parallel=false
#thread cap for parallel transfers, can interact with pool settings above, set to 0 for no max, transfer.use.parallel overrides this
transfer.max.parallel.threads=4
# UDP not currently supported
transfer.use.udp=false

#---------------
# properties controlling general behaviors
#=--------------

#if i cannot browse under root, attempt to find the /zone/home/public subdirectory and the user home directory
default.to.public.if.nothing.under.root.when.listing=true

